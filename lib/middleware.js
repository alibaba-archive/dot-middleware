/*!
 * doT - middleware (adapted from the stylus middleware)
 *
 * Original Copyright(c) 2010 LearnBoost <dev@learnboost.com>
 * MIT Licensed
 */

var dot    = require('dot')
	, fs     = require('fs')
	, url    = require('url')
	, path   = require('path')
	, mkdirp = require('mkdirp')
	, UglifyJS = require("uglify-js");

// Import map
var imports = {};

/**
 * Return Connect middleware with the given `options`.
 *
 * Options:
 *
 *    `force`           Always re-compile
 *    `once`            Only re-compile the one time
 *    `debug`           Output debugging information
 *    `src`             Source directory used to find .dot files
 *    `dest`            Destination directory used to output .template files
 *                      when undefined defaults to `src`.
 *    `prefix`          Path which should be stripped from `pathname`.
 *    `compress`        Whether the output .template files should be compressed
 *    `optimization`    The desired value of the dot optimization option (0, 1, or 2. 0 is default)
 *    `dumpLineNumbers` Add line tracking to the compiled template. ('comments' or 'mediaquery')
 *
 * Examples:
 *
 * Pass the middleware to Connect, grabbing .dot files from this directory
 * and saving .template files to _./public_. Also supplying our custom `compile` function.
 *
 * Following that we have a `static` layer setup to serve the .template
 * files generated by Less.
 *
 *      var server = connect.createServer(
 *          dot.middleware({
 *              src: __dirname + '/public',
 *              compress: true
 *          })
 *        , connect.static(__dirname + '/public')
 *      );
 *
 * @param {Object} options
 * @return {Function}
 * @api public
 */
module.exports = dot.middleware = function(options){
	var regex = {
		handle: /\.js$/,
		compress: /(\.|-)min\.js$/
	};

	options = options || {};

	// Accept src/dest dir
	if ('string' === typeof options) {
		options = { src: options };
	}

	// Only log if in debug mode
	var log = function(key, val, type) {
		if(options.debug || type === 'error') {
			switch(type) {
				case 'log':
				case 'info':
				case 'error':
				case 'warn':
					break;
				default:
					type = 'log';
			}

			console[type]('  \033[90m%s :\033[0m \033[36m%s\033[0m', key, val);
		}
	};

	var dotError = function(err) {
		log("doT " + err.type + ' error', err.message, 'error');
		log("doT File", err.filename + ' ' + err.line + ':' + err.column, 'error');
	};

	// Check imports for changes
	var checkImports = function(path, next) {
		var nodes = imports[path];

		if (!nodes || !nodes.length) {
			return next();
		}

		var pending = nodes.length;
		var changed = [];

		nodes.forEach(function(imported){
			fs.stat(imported.path, function(err, stat) {
				// error or newer mtime
				if (err || !imported.mtime || stat.mtime > imported.mtime) {
					changed.push(imported.path);
				}

				--pending || next(changed);
			});
		});
	}

	// File Extension option

	options.extension = options.extension || 'dot';

	// Once option
	options.once = options.once || false;

	// Compress option
	options.compress = typeof options.compress === 'undefined' ? 'auto' : options.compress;
	
	// Optimization option
	options.optimization = options.optimization || 0;

	// Line Number Tracking
	options.dumpLineNumbers = options.dumpLineNumbers || 0;

	// Source dir required
	var src = options.src;
	if (!src) { throw new Error('dot.middleware() requires "src" directory'); }

	// Default dest dir to source
	var dest = options.dest ? options.dest : src;

	if (options.paths){
		if (!(options.paths instanceof Array)) {
			options.paths = [options.paths];
		}
	} else {
		options.paths = [];
	}

	// Default compile callback
	options.render = options.render || function(str, srcPath, destPath, callback) {

		var paths = [ path.dirname(srcPath) ];
		options.paths.forEach(function(p){ paths.push(p); });

		var code = dot.template(str).toString();
		// make template amd ready
		if (options.amd) {
			code = 'define([],function(){return ' + code + '});';
		}
		// compressed code here
		if (options.compress) {
			code =  UglifyJS.minify(code, {
				fromString: true
			}).code; 
		} 
		return callback(null, code);
		// try {
		//   var code = dot.template(data).toString();
		// } catch(compileError) {
		//   callback(null, code);
		// }
		// parser.parse(str, function(err, tree) {
		//   try {
		//     if (err) {
		//       callback(err, template);
		//       return;
		//     }

		//     var template = tree.toCSS({
		//       compress: (options.compress == 'auto' ? regex.compress.test(destPath) : options.compress),
		//       yuicompress: options.yuicompress
		//     });

		//     // Store the dot import paths
		//     imports[srcPath] = tree.rules
		//       .filter(function(rule) {
		//         return rule.path;
		//       })
		//       .map(function(rule) {
		//         return {
		//           mtime : Date.now(),
		//           path : path.join(path.dirname(srcPath), rule.path)
		//         };
		//       });

		//     callback(err, template);
		//   } catch(parseError) {
		//     callback(parseError, null);
		//   }
		// });
	};

	// Middleware
	return function(req, res, next) {
		if ('GET' != req.method.toUpperCase() && 'HEAD' != req.method.toUpperCase()) { return next(); }

		var pathname = url.parse(req.url).pathname;
		// Only handle the matching files
		if (regex.handle.test(pathname)) {
			if (pathname.indexOf('templates') === -1) {
				return next();
			}
			if (options.prefix && 0 === pathname.indexOf(options.prefix)) {
				pathname = pathname.substring(options.prefix.length);
			}

			var destPath = path.join(dest, pathname);
			var srcPath = path.join(src, (
				regex.compress.test(pathname)
				? pathname.replace(regex.compress, '.' + options.extension)
				: pathname.replace(regex.handle, '.' + options.extension)
			));

			log('source', srcPath);
			log('dest', destPath);

			// Ignore ENOENT to fall through as 404
			var error = function(err) {
				return next('ENOENT' == err.code ? null : err);
			};

			// Compile to destPath
			var compile = function() {
				log('read', srcPath);

				fs.readFile(srcPath, 'utf8', function(err, str){
					if (err) { return error(err); }
					delete imports[srcPath];

					try {
						options.render(str, srcPath, destPath, function(err, template){
							if (err) {
								dotError(err);

								return next(err);
							}

							log('render', srcPath);

							mkdirp(path.dirname(destPath), 0777, function(err){
								if (err) return error(err);

								fs.writeFile(destPath, template, 'utf8', next);
							});
						});
					} catch (err) {
						dotError(err);

						return next(err);
					}
				});
			};

			// Force
			if (options.force) { return compile(); }

			// Re-compile on server restart, disregarding
			// mtimes since we need to map imports
			if (!imports[srcPath]) { return compile(); }

			// Only check/recompile if it has not been done at before
			if (options.once && imports[srcPath]) { return next(); }

			// Compare mtimes
			fs.stat(srcPath, function(err, dotStats){
				if (err) { return error(err); }

				fs.stat(destPath, function(err, templateStats){
					// template has not been compiled, compile it!
					if (err) {
						if ('ENOENT' == err.code) {
							log('not found', destPath);

							// No template file found in dest
							return compile();
						} else {
							return next(err);
						}
					} else if (dotStats.mtime > templateStats.mtime) {
						// Source has changed, compile it
						log('modified', destPath);

						return compile();
					} else {
						// Check if any of the dot imports were changed
						checkImports(srcPath, function(changed){
							if(typeof changed != "undefined" && changed.length) {
								log('modified import', changed);

								return compile();
							}

							return next();
						});
					}
				});
			});
		} else {
			return next();
		}
	};
};
